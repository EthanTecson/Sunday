—
course: “CS371”
lecture: “Lecture 01 - First Class/overview”
date: “2025-8-29”
tags:  [“algorithms”, “topics”]
—
So, what is this course? We all know why we're here, right?  Algorithms. The title is a little longer than that, but it really what we really care about here is this algorithms. So you've gone through the entire sequence of all the courses or most of the courses, you were required to take for the major, you've gone through your CS1, your CS2, your 271, maybe1.  And this is a word that comes up in every class. and maybe folks, when they hear you do computer science, ask you about this stuff. But what is an algorithm? Fundamental?  It's like a solution to a specific problem. More general than that. More general??  Uh. Code. Wrong direction, but I like the talk.  You guys are here for. Instruction. Instructions, right?  So everything to do with, like, really fundamentally, algorithms are instructions, right? The reason why I want you to think about it in terms of instructions for so that this solution to a problem is because an algorithm strictly speaking is something that is just a sequence of steps, whether you are trying to solve a specific problem or not. It helps us think about these things a bit more abstractly.  But really, when we're dealing with algorithms, we're really just thinking about instructions. Okay? And the reason why I bring that up is that these instructions have a purpose, and it's exactly the what Amy gave us is that generally we use them to solve problems.  It's not true to say that an algorithm is always for solving the problem, although some people will argue against that, I think that's one of the things we're allowed to disagree on when it comes to definitions. But it really is instructions to solve problems. Now, we said something interesting about code.  Here. And one of the things that I want here to. internalize early on in the year, because as you go through the courses, sometimes that the line gets blurred, is that these clues are not. Algorithms and include are fundamental different things.  So we'll look at a lot of algorithms who study a lot of algorithms in this course, but we're not going to do a whole lot of actual coding. We mean your homeworks, you're not go to a bit more detail about the homeworks, and we'll do some coding every so often, but really what I want you to get comfortable doing is providing these instructions and pseudo code as you may have been doing in some of your courses, or maybe you've lost that skill a little bit, so that was a good time to brush up audits. and reading these same types of instructions in form of pseudo code to do something additional, which is analysis. So probably one of the most painful things about this course is the amount of analysis we'll do.  And the reason why we do it is really because, you know, you write the piece of code, how do you know it's code? Analysis, right? We do analysis, we use our math, then we picked up from 234, from 271.  We use this techniques, these lin variariants, induction, all these kinds of things, to really be able to come up with ways to argue that whatever we're writing down, whatever those instructions we're writing down, are truly doing what it is that we want to do. All right? So you'll do a bit of coating, but that's not the main bowl of this course.  It's really understanding these instructions and their analysis. And we'll go over a variety of different techniques. So we'll focus a lot on techniques for algorithms.  Okay? The first one that we'll look at is going to be the greedy technique, the greedy approach for algorithms, and then we'll look at divide and conquer. followed by dynamic programming. And in each case, we will justify why we need to use a different technique for what we're doing, and then we'll look at some applications of some of these techniques.  And let's say further approaches by looking at things such as flows and deductions, and anecal weness. Okay. So this is really the layout of what's going to happen.  We're going to spend about a couple weeks on this a little longer here, a little longer here, and then about half the term of these topics. And these techniques are all going to be solving different kinds of problems, so you'll see a variety of problems in this course. And sometimes it may feel like these problems are not useful.  At least, I hope you won't feel like that, but sometimes you may feel with this problem feels artificial, that needs to write bigger on the back, is that 
